rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    function isAuthenticated() { return request.auth != null; }
    function isCustomer() { return isAuthenticated() && exists(/databases/$(database)/documents/customers/$(request.auth.uid)); }
    function isCompany() { return isAuthenticated() && exists(/databases/$(database)/documents/companies/$(request.auth.uid)); }
    function isRequestOwner(reqId) {
      return isAuthenticated()
        && get(/databases/$(database)/documents/requests/$(reqId)).data.customerId == request.auth.uid;
    }

    // Customers can manage only their document
    match /customers/{customerId} {
      // Everyone can read their own customer profile; block cross-user reads
      allow read: if isAuthenticated() && request.auth.uid == customerId;

      // Prevent dual-role: cannot create customer profile if a company profile exists
      allow create: if isAuthenticated()
        && request.auth.uid == customerId
        && !exists(/databases/$(database)/documents/companies/$(request.auth.uid));

      // Update only own document
      allow update: if isAuthenticated() && request.auth.uid == customerId;
    }

    // Companies
    match /companies/{companyId} {
      // Public company profiles
      allow read: if true;

      // Company can create its own profile (prevent dual-role if a customer doc already exists)
      allow create: if isAuthenticated()
        && request.auth.uid == companyId
        && !exists(/databases/$(database)/documents/customers/$(request.auth.uid));

      // Update only own profile (optional: protect aggregates if you add them later)
      allow update: if isAuthenticated() && request.auth.uid == companyId;

      // Reviews subcollection
      match /reviews/{reviewId} {
        allow read: if true;

        // Customers can create reviews only for completed requests they own
        allow create: if isAuthenticated()
          && request.resource.data.companyId == companyId
          && request.resource.data.customerId == request.auth.uid
          && request.resource.data.rating is int
          && request.resource.data.rating >= 1 && request.resource.data.rating <= 5
          && request.resource.data.requestId is string
          && get(/databases/$(database)/documents/requests/$(request.resource.data.requestId)).data.customerId == request.auth.uid
          && get(/databases/$(database)/documents/requests/$(request.resource.data.requestId)).data.status == "completed";

        // Optional: author can edit/delete within 24h
        allow update, delete: if isAuthenticated()
          && resource.data.customerId == request.auth.uid
          && resource.data.createdAt != null
          && request.time < resource.data.createdAt + duration.value(24, 'h');
      }

      // Notifications subcollection
      match /notifications/{notifId} {
        // Companies can read/manage their own notifications
        allow read, update, delete: if isCompany() && request.auth.uid == companyId;

        // Allow the owner of a request to create a notification for a company
        // (used when client actualizează o cerere și vrea să notifice companiile interesate)
        allow create: if isAuthenticated()
          && request.resource.data.requestId is string
          && isRequestOwner(request.resource.data.requestId);
      }
    }

    // Requests
    match /requests/{requestId} {
      // Customers: can read doar propriile cereri
      // Companies: pot citi doar cererile active și nearhivate
      allow read: if (
          isCustomer() && resource.data.customerId == request.auth.uid
        ) || (
          isCompany() && resource.data.archived != true && (
            resource.data.status == "active" || !("status" in resource.data)
          )
        );

      // Customers create their own requests
      allow create: if isCustomer() && request.resource.data.customerId == request.auth.uid;

      // Customers can update/delete only their own requests
      allow update, delete: if isAuthenticated() && resource.data.customerId == request.auth.uid;

      // Offers subcollection
      match /offers/{offerId} {
        // Read:
        // - Customer: poate citi ofertele la cererea proprie
        // - Company: poate citi doar ofertele proprii
        allow read: if (
            isCustomer() && isRequestOwner(requestId)
          ) || (
            isCompany() && resource.data.companyId == request.auth.uid
          );

        // Create: company postează ofertă doar pe cereri active și nearhivate
        allow create: if isCompany()
          && request.resource.data.companyId == request.auth.uid
          && request.resource.data.status == "pending"
          && get(/databases/$(database)/documents/requests/$(requestId)).data.archived != true
          && (
            get(/databases/$(database)/documents/requests/$(requestId)).data.status == "active" ||
            !("status" in get(/databases/$(database)/documents/requests/$(requestId)).data)
          );

        // Companies can update/delete only their own offers
        allow update, delete: if isCompany() && resource.data.companyId == request.auth.uid;
      }
    }

    // Upload tokens - server-generated; customers can only mark them as used
    match /uploadTokens/{token} {
      // Server/Admin only (API using Admin SDK bypasses rules)
      allow read, create: if false;

      // Customer who owns the related request can mark the token as used
      allow update: if isAuthenticated()
        && get(/databases/$(database)/documents/requests/$(resource.data.requestId)).data.customerId == request.auth.uid
        && request.resource.data.diff(resource.data).changedKeys().hasOnly(["used","uploadedAt"]) 
        && request.resource.data.used == true;
    }
  }
}
