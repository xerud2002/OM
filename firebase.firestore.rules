rules_version = '2';

service cloud.firestore {
  match /databases/{database}/documents {
    // Helper functions
    function isSignedIn() { return request.auth != null; }

    // Role helpers (no dynamic path concatenation)
    function isCustomer() { return exists(/databases/$(database)/documents/customers/$(request.auth.uid)); }
    function isCompany() { return exists(/databases/$(database)/documents/companies/$(request.auth.uid)); }
    function canCreateCustomer() { return !isCompany(); }
    function canCreateCompany() { return !isCustomer(); }

    // === CUSTOMERS COLLECTION ===
    match /customers/{customerId} {
      allow read: if isSignedIn() && request.auth.uid == customerId;
      allow create: if isSignedIn() && request.auth.uid == customerId && canCreateCustomer();
      allow update: if isSignedIn() && request.auth.uid == customerId;
      allow delete: if false; // Prevent deletion
    }

    // === COMPANIES COLLECTION ===
    match /companies/{companyId} {
      allow read: if isSignedIn() && request.auth.uid == companyId;
      allow create: if isSignedIn() && request.auth.uid == companyId && canCreateCompany();
      allow update: if isSignedIn() && request.auth.uid == companyId;
      allow delete: if false; // Prevent deletion

      // Company notifications subcollection
      match /notifications/{notificationId} {
        allow read: if isSignedIn() && request.auth.uid == companyId;
        allow write: if false; // Created by server or Cloud Functions
      }

      // Company payments subcollection
      match /payments/{requestId} {
        // Company can read their own payments
        allow read: if isSignedIn() && request.auth.uid == companyId;
        // Company can create payment records for requests they want to access
        allow create: if isSignedIn() && 
          request.auth.uid == companyId &&
          request.resource.data.companyId == companyId &&
          request.resource.data.requestId == requestId &&
          request.resource.data.status == 'completed';
        // No updates or deletes allowed
        allow update, delete: if false;
      }
    }

    // === REQUESTS COLLECTION ===
    match /requests/{requestId} {
      // Companies can read all requests; customers can read their own
      allow read: if isSignedIn() && (
        isCompany() ||
        resource.data.customerId == request.auth.uid
      );

      // Customers can create requests linked to their account
      allow create: if isSignedIn() && isCustomer() && request.resource.data.customerId == request.auth.uid;
      
      // Guest requests (unauthenticated) - requires guestEmail and no customerId
      allow create: if request.auth == null && 
        request.resource.data.guestEmail is string &&
        request.resource.data.guestEmail.size() > 5 &&
        request.resource.data.customerId == null &&
        request.resource.data.status == 'active';

      // Only request owner can update their request
      allow update: if isSignedIn() && resource.data.customerId == request.auth.uid;

      // No hard deletes (use archived flag instead)
      allow delete: if false;

      // === OFFERS SUBCOLLECTION ===
      match /offers/{offerId} {
        // Request owner and offer company can read
        allow get, list: if isSignedIn() && (
          resource.data.companyId == request.auth.uid ||
          get(/databases/$(database)/documents/requests/$(requestId)).data.customerId == request.auth.uid
        );

        // Only companies can create offers for requests on active, non-archived requests
        allow create: if isSignedIn() &&
          isCompany() &&
          request.resource.data.companyId == request.auth.uid &&
          // Request must not be archived
          !(get(/databases/$(database)/documents/requests/$(requestId)).data.archived == true) &&
          // And request status must not be closed or cancelled
          !(
            get(/databases/$(database)/documents/requests/$(requestId)).data.status == 'closed' ||
            get(/databases/$(database)/documents/requests/$(requestId)).data.status == 'cancelled'
          );

        // Strict updates:
        // - Company (owner) may only change price/message (and not rebind companyId/requestId)
        // - Customer (request owner) may only change status to accepted|declined
        allow update: if isSignedIn() && (
          // Company edits: limit to price/message fields
          (
            resource.data.companyId == request.auth.uid &&
            request.resource.data.companyId == resource.data.companyId &&
            request.resource.data.requestId == resource.data.requestId &&
            request.resource.data.diff(resource.data).changedKeys().hasOnly(['price','message'])
          ) ||
          // Customer accepts/declines: limit to status only
          (
            get(/databases/$(database)/documents/requests/$(requestId)).data.customerId == request.auth.uid &&
            request.resource.data.diff(resource.data).changedKeys().hasOnly(['status']) &&
            (request.resource.data.status == 'accepted' || request.resource.data.status == 'declined')
          )
        );

        // No deletion via client SDK
        allow delete: if false;

        // === MESSAGES SUBCOLLECTION ===
        match /messages/{messageId} {
          // Request owner and offer company can read their conversation
          allow get, list: if isSignedIn() && (
            get(/databases/$(database)/documents/requests/$(requestId)).data.customerId == request.auth.uid ||
            get(/databases/$(database)/documents/requests/$(requestId)/offers/$(offerId)).data.companyId == request.auth.uid
          );
          // Allow either party to create a message with restricted fields
          allow create: if isSignedIn() && (
            get(/databases/$(database)/documents/requests/$(requestId)).data.customerId == request.auth.uid ||
            get(/databases/$(database)/documents/requests/$(requestId)/offers/$(offerId)).data.companyId == request.auth.uid
          ) && 
          request.resource.data.senderId == request.auth.uid &&
          request.resource.data.keys().hasAll(['text','senderId','senderRole','createdAt']) &&
          request.resource.data.keys().hasOnly(['text','senderId','senderRole','createdAt']);
          // No client updates/deletes to messages
          allow update, delete: if false;
        }
      }
    }

    // === UPLOAD TOKENS COLLECTION ===
    match /uploadTokens/{tokenId} {
      // Keep tokens hidden from clients
      allow get, list: if false;
      // Allow customers to mark their own token as used (optional; prefer server API)
      allow update: if isSignedIn() &&
        // Ensure token is bound to a request owned by the caller
        get(/databases/$(database)/documents/requests/$(resource.data.requestId)).data.customerId == request.auth.uid &&
        // Only allow flipping used flag and setting uploadedAt
        request.resource.data.diff(resource.data).changedKeys().hasOnly(['used','uploadedAt']) &&
        request.resource.data.used == true;
      // No creates/deletes from client
      allow create, delete: if false;
    }

    // === META COLLECTION (for counters and system data) ===
    match /meta/{docId} {
      // Allow authenticated users to read and write counters (for request code generation)
      // Also allow unauthenticated for guest request code generation
      allow read, write: if docId == 'counters';
      // Deny all other meta documents
      allow read, write: if false;
    }

    // Deny everything else by default
    match /{document=**} {
      allow read, write: if false;
    }
  }
}