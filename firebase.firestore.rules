rules_version = '2';

service cloud.firestore {
  match /databases/{database}/documents {
    // Helper functions
    function isSignedIn() { return request.auth != null; }

    // Role helpers (no dynamic path concatenation)
    function isCustomer() { return exists(/databases/$(database)/documents/customers/$(request.auth.uid)); }
    function isCompany() { return exists(/databases/$(database)/documents/companies/$(request.auth.uid)); }
    function isAdmin() { return exists(/databases/$(database)/documents/admins/$(request.auth.uid)); }
    function canCreateCustomer() { return !isCompany(); }
    function canCreateCompany() { return !isCustomer(); }

    // === COLLECTION GROUP RULES (must be at top level for collectionGroup queries) ===
    // Allow companies to query their own offers across all requests via collectionGroup
    match /{path=**}/offers/{offerId} {
      allow read: if isSignedIn() && resource.data.companyId == request.auth.uid;
    }

    // === CUSTOMERS COLLECTION ===
    match /customers/{customerId} {
      allow read: if isSignedIn() && (request.auth.uid == customerId || isAdmin());
      allow create: if isSignedIn() && request.auth.uid == customerId && canCreateCustomer();
      // Customer can update own profile, but cannot change identity fields
      allow update: if isSignedIn() && (
        (request.auth.uid == customerId &&
          !request.resource.data.diff(resource.data).changedKeys().hasAny(['role', 'uid', 'createdAt'])
        ) ||
        isAdmin()
      );
      allow delete: if isSignedIn() && isAdmin(); // Only admin can delete

      // Customer notifications subcollection
      match /notifications/{notificationId} {
        allow read: if isSignedIn() && request.auth.uid == customerId;
        // Customer can only mark notifications as read
        allow update: if isSignedIn() && request.auth.uid == customerId
          && request.resource.data.diff(resource.data).changedKeys().hasOnly(['read']);
        allow create, delete: if false; // Created by server only
      }
    }

    // === COMPANIES COLLECTION ===
    match /companies/{companyId} {
      // Anyone can read a single company doc (needed for reviews page, public profiles)
      allow get: if true;
      // List queries restricted to signed-in company owner or admin
      allow list: if isSignedIn() && (request.auth.uid == companyId || isAdmin());
      allow create: if isSignedIn() && request.auth.uid == companyId && canCreateCompany();
      // Admin can update any field (verification, credits, etc.)
      allow update: if isSignedIn() && isAdmin();
      // Company can update own profile, but cannot self-inflate credits or change trust fields
      allow update: if isSignedIn() && request.auth.uid == companyId &&
        // Cannot change protected identity/trust/rating fields
        !request.resource.data.diff(resource.data).changedKeys().hasAny([
          'verificationStatus', 'verified', 'averageRating', 'totalReviews',
          'role', 'uid', 'walletBalance', 'freeLeadCredits',
          'welcomeCreditsReceived', 'firstPurchaseBonusAvailable'
        ]) &&
        // Credits can only decrease (for offer deductions), never increase
        (!request.resource.data.diff(resource.data).changedKeys().hasAny(['credits']) ||
         request.resource.data.credits <= resource.data.credits);
      allow delete: if false; // Prevent deletion

      // Company notifications subcollection
      match /notifications/{notificationId} {
        allow read: if isSignedIn() && request.auth.uid == companyId;
        // Company can only mark notifications as read
        allow update: if isSignedIn() && request.auth.uid == companyId
          && request.resource.data.diff(resource.data).changedKeys().hasOnly(['read']);
        allow create, delete: if false; // Created by server only
      }

      // Company payments subcollection
      match /payments/{requestId} {
        // Company can read their own payments
        allow read: if isSignedIn() && request.auth.uid == companyId;
        // Company can create payment records for requests they want to access
        allow create: if isSignedIn() && 
          request.auth.uid == companyId &&
          request.resource.data.companyId == companyId &&
          request.resource.data.requestId == requestId &&
          request.resource.data.status == 'completed';
        // No updates or deletes allowed
        allow update, delete: if false;
      }

      // Company transactions subcollection (for credit audit trail)
      match /transactions/{transactionId} {
        // Company can read their own transactions
        allow read: if isSignedIn() && request.auth.uid == companyId;
        // Company can create transaction records (offer placements, credit purchases)
        allow create: if isSignedIn() && 
          request.auth.uid == companyId &&
          request.resource.data.keys().hasAll(['type', 'amount', 'createdAt']);
        // No updates or deletes allowed
        allow update, delete: if false;
      }
    }

    // === REQUESTS COLLECTION ===
    match /requests/{requestId} {
      // Read rules:
      // - Companies can read all requests (for browsing available work)
      // - Customers can read their own requests (customerId matches)
      // - For list queries, we also allow any signed-in customer to query (the query itself filters by customerId)
      allow read: if isSignedIn() && (
        isCompany() ||
        resource.data.customerId == request.auth.uid ||
        isAdmin()
      );

      // Customers can create requests linked to their account
      allow create: if isSignedIn() && isCustomer() && request.resource.data.customerId == request.auth.uid;
      
      // Guest requests (unauthenticated) - requires guestEmail and no customerId
      allow create: if request.auth == null && 
        request.resource.data.guestEmail is string &&
        request.resource.data.guestEmail.size() > 5 &&
        request.resource.data.customerId == null &&
        request.resource.data.status == 'active';

      // Only request owner can update their request, admin can also update
      allow update: if isSignedIn() && (resource.data.customerId == request.auth.uid || isAdmin());

      // Only admin can delete
      allow delete: if isSignedIn() && isAdmin();

      // === OFFERS SUBCOLLECTION ===
      match /offers/{offerId} {
        // Request owner and offer company can read
        allow get, list: if isSignedIn() && (
          resource.data.companyId == request.auth.uid ||
          (exists(/databases/$(database)/documents/requests/$(requestId)) && 
           get(/databases/$(database)/documents/requests/$(requestId)).data.customerId == request.auth.uid)
        );

        // Only companies can create offers for requests on active, non-archived requests
        allow create: if isSignedIn() &&
          request.resource.data.companyId == request.auth.uid &&
          !(get(/databases/$(database)/documents/requests/$(requestId)).data.archived == true) &&
          !(
            get(/databases/$(database)/documents/requests/$(requestId)).data.status == 'closed' ||
            get(/databases/$(database)/documents/requests/$(requestId)).data.status == 'cancelled'
          );

        // Strict updates:
        // - Company (owner) may only change price/message (and not rebind companyId/requestId)
        // - Customer (request owner) may only change status to accepted|declined
        allow update: if isSignedIn() && (
          // Company edits: limit to price/message fields
          (
            resource.data.companyId == request.auth.uid &&
            request.resource.data.companyId == resource.data.companyId &&
            request.resource.data.requestId == resource.data.requestId &&
            request.resource.data.diff(resource.data).changedKeys().hasOnly(['price','message'])
          ) ||
          // Customer accepts/declines: limit to status only
          (
            get(/databases/$(database)/documents/requests/$(requestId)).data.customerId == request.auth.uid &&
            request.resource.data.diff(resource.data).changedKeys().hasOnly(['status']) &&
            (request.resource.data.status == 'accepted' || request.resource.data.status == 'declined')
          )
        );

        // No deletion via client SDK
        allow delete: if false;

        // === MESSAGES SUBCOLLECTION ===
        match /messages/{messageId} {
          // Request owner and offer company can read their conversation
          allow get, list: if isSignedIn() && (
            get(/databases/$(database)/documents/requests/$(requestId)).data.customerId == request.auth.uid ||
            get(/databases/$(database)/documents/requests/$(requestId)/offers/$(offerId)).data.companyId == request.auth.uid
          );
          // Allow either party to create a message with restricted fields
          allow create: if isSignedIn() && (
            get(/databases/$(database)/documents/requests/$(requestId)).data.customerId == request.auth.uid ||
            get(/databases/$(database)/documents/requests/$(requestId)/offers/$(offerId)).data.companyId == request.auth.uid
          ) && 
          request.resource.data.senderId == request.auth.uid &&
          request.resource.data.keys().hasAll(['text','senderId','senderRole','createdAt']) &&
          request.resource.data.keys().hasOnly(['text','senderId','senderRole','createdAt','attachment']);
          // No client updates/deletes to messages
          allow update, delete: if false;
        }

        // === TYPING INDICATORS SUBCOLLECTION ===
        match /typing/{role} {
          // Both parties can read typing indicators
          allow read: if isSignedIn() && (
            get(/databases/$(database)/documents/requests/$(requestId)).data.customerId == request.auth.uid ||
            get(/databases/$(database)/documents/requests/$(requestId)/offers/$(offerId)).data.companyId == request.auth.uid
          );
          // Either party can write/delete their own typing indicator (role == "customer" or "company")
          allow write: if isSignedIn() && (
            (role == 'customer' && get(/databases/$(database)/documents/requests/$(requestId)).data.customerId == request.auth.uid) ||
            (role == 'company' && get(/databases/$(database)/documents/requests/$(requestId)/offers/$(offerId)).data.companyId == request.auth.uid)
          );
        }
      }
    }

    // === UPLOAD TOKENS COLLECTION ===
    match /uploadTokens/{tokenId} {
      // Keep tokens hidden from clients
      allow get, list: if false;
      // Allow customers to mark their own token as used (optional; prefer server API)
      allow update: if isSignedIn() &&
        // Ensure token is bound to a request owned by the caller
        get(/databases/$(database)/documents/requests/$(resource.data.requestId)).data.customerId == request.auth.uid &&
        // Only allow flipping used flag and setting uploadedAt
        request.resource.data.diff(resource.data).changedKeys().hasOnly(['used','uploadedAt']) &&
        request.resource.data.used == true;
      // No creates/deletes from client
      allow create, delete: if false;
    }

    // === ADMINS COLLECTION ===
    match /admins/{adminId} {
      // Only the admin can read their own profile (for role detection)
      allow read: if isSignedIn() && request.auth.uid == adminId;
      // No client-side writes - admins are created manually in Firebase Console
      allow write: if false;
    }

    // === META COLLECTION (for counters and system data) ===
    match /meta/{docId} {
      // Authenticated users can read/write counters (for request code generation)
      // NOTE: Guest request fallback (client-side) requires auth; primary path uses Admin SDK
      allow read, write: if isSignedIn() && docId == 'counters';
      // Admin can read and write settings
      allow read, write: if docId == 'settings' && isSignedIn() && isAdmin();
      // Deny all other meta documents
      allow read, write: if false;
    }

    // === ARTICLES COLLECTION (Content Management) ===
    match /articles/{articleId} {
      // Public read access ONLY for published articles
      allow read: if resource.data.status == 'published' && 
                     resource.data.archived != true;
      
      // Admin write access only - secured for production
      allow create, update: if isSignedIn() && isAdmin();
      
      // No deletion - use archived flag instead
      allow delete: if false;
    }

    // === REVIEWS COLLECTION ===
    match /reviews/{reviewId} {
      // Public read access to all published reviews
      allow read: if resource.data.status == 'published';
      
      // Anyone can create a review (guests via email link); verify company exists to prevent spam
      allow create: if 
        exists(/databases/$(database)/documents/companies/$(request.resource.data.companyId)) &&
        request.resource.data.keys().hasAll(['companyId', 'customerName', 'rating', 'comment', 'createdAt', 'status']) &&
        request.resource.data.companyId is string &&
        request.resource.data.customerName is string &&
        request.resource.data.customerName.size() >= 2 &&
        request.resource.data.rating >= 1 &&
        request.resource.data.rating <= 5 &&
        request.resource.data.comment is string &&
        request.resource.data.comment.size() >= 10 &&
        request.resource.data.status == 'published';
      
      // Admin can update reviews (for moderation)
      allow update: if isSignedIn() && isAdmin();
      
      // No deletion
      allow delete: if false;
    }

    // === FRAUD DETECTION (server-side only via Admin SDK) ===
    // deviceFingerprints: stores device fingerprint + IP per user
    match /deviceFingerprints/{docId} {
      allow read, write: if false; // Admin SDK bypasses rules
    }
    // fraudFlags: stores multi-account fraud flags
    match /fraudFlags/{flagId} {
      allow read, write: if false; // Admin SDK bypasses rules
    }

    // === ADMIN COLLECTIONS (server-side only via Admin SDK) ===
    match /adminAuditLog/{docId} {
      allow read, write: if false; // Admin SDK bypasses rules
    }
    match /systemLogs/{docId} {
      allow read, write: if false; // Admin SDK bypasses rules
    }
    match /suspensions/{docId} {
      allow read, write: if false; // Admin SDK bypasses rules
    }

    // Deny everything else by default
    match /{document=**} {
      allow read, write: if false;
    }
  }
}