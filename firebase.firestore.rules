rules_version = '2';

service cloud.firestore {
  match /databases/{database}/documents {
    // Helper functions
    function isSignedIn() { return request.auth != null; }

    // Role helpers (no dynamic path concatenation)
    function isCustomer() { return exists(/databases/$(database)/documents/customers/$(request.auth.uid)); }
    function isCompany() { return exists(/databases/$(database)/documents/companies/$(request.auth.uid)); }
    function isAdmin() { return exists(/databases/$(database)/documents/admins/$(request.auth.uid)); }
    function canCreateCustomer() { return !isCompany(); }
    function canCreateCompany() { return !isCustomer(); }

    // === CUSTOMERS COLLECTION ===
    match /customers/{customerId} {
      allow read: if isSignedIn() && (request.auth.uid == customerId || isAdmin());
      allow create: if isSignedIn() && request.auth.uid == customerId && canCreateCustomer();
      allow update: if isSignedIn() && (request.auth.uid == customerId || isAdmin());
      allow delete: if isSignedIn() && isAdmin(); // Only admin can delete
    }

    // === COMPANIES COLLECTION ===
    match /companies/{companyId} {
      // Admin can read all companies, company can only read own
      allow read: if isSignedIn() && (request.auth.uid == companyId || isAdmin());
      allow create: if isSignedIn() && request.auth.uid == companyId && canCreateCompany();
      // Admin can update any company (for verification), company can update own
      // Company credits updates are allowed for offer placements
      allow update: if isSignedIn() && (request.auth.uid == companyId || isAdmin());
      allow delete: if false; // Prevent deletion

      // Company notifications subcollection
      match /notifications/{notificationId} {
        allow read: if isSignedIn() && request.auth.uid == companyId;
        allow write: if false; // Created by server or Cloud Functions
      }

      // Company payments subcollection
      match /payments/{requestId} {
        // Company can read their own payments
        allow read: if isSignedIn() && request.auth.uid == companyId;
        // Company can create payment records for requests they want to access
        allow create: if isSignedIn() && 
          request.auth.uid == companyId &&
          request.resource.data.companyId == companyId &&
          request.resource.data.requestId == requestId &&
          request.resource.data.status == 'completed';
        // No updates or deletes allowed
        allow update, delete: if false;
      }

      // Company transactions subcollection (for credit audit trail)
      match /transactions/{transactionId} {
        // Company can read their own transactions
        allow read: if isSignedIn() && request.auth.uid == companyId;
        // Company can create transaction records (offer placements, credit purchases)
        allow create: if isSignedIn() && 
          request.auth.uid == companyId;
          // request.resource.data.keys().hasAll(['type', 'amount', 'createdAt']);
        // No updates or deletes allowed
        allow update, delete: if false;
      }
    }

    // === REQUESTS COLLECTION ===
    match /requests/{requestId} {
      // Read rules:
      // - Companies can read all requests (for browsing available work)
      // - Customers can read their own requests (customerId matches)
      // - For list queries, we also allow any signed-in customer to query (the query itself filters by customerId)
      allow read: if isSignedIn() && (
        isCompany() ||
        isCustomer() ||
        resource.data.customerId == request.auth.uid
      );

      // Customers can create requests linked to their account
      allow create: if isSignedIn() && isCustomer() && request.resource.data.customerId == request.auth.uid;
      
      // Guest requests (unauthenticated) - requires guestEmail and no customerId
      allow create: if request.auth == null && 
        request.resource.data.guestEmail is string &&
        request.resource.data.guestEmail.size() > 5 &&
        request.resource.data.customerId == null &&
        request.resource.data.status == 'active';

      // Only request owner can update their request, admin can also update
      allow update: if isSignedIn() && (resource.data.customerId == request.auth.uid || isAdmin());

      // Only admin can delete
      allow delete: if isSignedIn() && isAdmin();

      // === OFFERS SUBCOLLECTION ===
      match /offers/{offerId} {
        // Request owner and offer company can read
        allow get, list: if isSignedIn() && (
          resource.data.companyId == request.auth.uid ||
          (exists(/databases/$(database)/documents/requests/$(requestId)) && 
           get(/databases/$(database)/documents/requests/$(requestId)).data.customerId == request.auth.uid)
        );

        // Only companies can create offers for requests on active, non-archived requests
        allow create: if isSignedIn() &&
          isCompany() &&
          request.resource.data.companyId == request.auth.uid;
          // Temporarily removed extended validation for debugging
          // && !(get(/databases/$(database)/documents/requests/$(requestId)).data.archived == true) &&
          // !(
          //   get(/databases/$(database)/documents/requests/$(requestId)).data.status == 'closed' ||
          //   get(/databases/$(database)/documents/requests/$(requestId)).data.status == 'cancelled'
          // );

        // Strict updates:
        // - Company (owner) may only change price/message (and not rebind companyId/requestId)
        // - Customer (request owner) may only change status to accepted|declined
        allow update: if isSignedIn() && (
          // Company edits: limit to price/message fields
          (
            resource.data.companyId == request.auth.uid &&
            request.resource.data.companyId == resource.data.companyId &&
            request.resource.data.requestId == resource.data.requestId &&
            request.resource.data.diff(resource.data).changedKeys().hasOnly(['price','message'])
          ) ||
          // Customer accepts/declines: limit to status only
          (
            get(/databases/$(database)/documents/requests/$(requestId)).data.customerId == request.auth.uid &&
            request.resource.data.diff(resource.data).changedKeys().hasOnly(['status']) &&
            (request.resource.data.status == 'accepted' || request.resource.data.status == 'declined')
          )
        );

        // No deletion via client SDK
        allow delete: if false;

        // === MESSAGES SUBCOLLECTION ===
        match /messages/{messageId} {
          // Request owner and offer company can read their conversation
          allow get, list: if isSignedIn() && (
            get(/databases/$(database)/documents/requests/$(requestId)).data.customerId == request.auth.uid ||
            get(/databases/$(database)/documents/requests/$(requestId)/offers/$(offerId)).data.companyId == request.auth.uid
          );
          // Allow either party to create a message with restricted fields
          allow create: if isSignedIn() && (
            get(/databases/$(database)/documents/requests/$(requestId)).data.customerId == request.auth.uid ||
            get(/databases/$(database)/documents/requests/$(requestId)/offers/$(offerId)).data.companyId == request.auth.uid
          ) && 
          request.resource.data.senderId == request.auth.uid &&
          request.resource.data.keys().hasAll(['text','senderId','senderRole','createdAt']) &&
          request.resource.data.keys().hasOnly(['text','senderId','senderRole','createdAt']);
          // No client updates/deletes to messages
          allow update, delete: if false;
        }
      }
    }

    // === UPLOAD TOKENS COLLECTION ===
    match /uploadTokens/{tokenId} {
      // Keep tokens hidden from clients
      allow get, list: if false;
      // Allow customers to mark their own token as used (optional; prefer server API)
      allow update: if isSignedIn() &&
        // Ensure token is bound to a request owned by the caller
        get(/databases/$(database)/documents/requests/$(resource.data.requestId)).data.customerId == request.auth.uid &&
        // Only allow flipping used flag and setting uploadedAt
        request.resource.data.diff(resource.data).changedKeys().hasOnly(['used','uploadedAt']) &&
        request.resource.data.used == true;
      // No creates/deletes from client
      allow create, delete: if false;
    }

    // === ADMINS COLLECTION ===
    match /admins/{adminId} {
      // Only the admin can read their own profile (for role detection)
      allow read: if isSignedIn() && request.auth.uid == adminId;
      // No client-side writes - admins are created manually in Firebase Console
      allow write: if false;
    }

    // === META COLLECTION (for counters and system data) ===
    match /meta/{docId} {
      // Allow authenticated users to read and write counters (for request code generation)
      allow read, write: if docId == 'counters';
      // Admin can read and write settings
      allow read, write: if docId == 'settings' && isSignedIn() && isAdmin();
      // Deny all other meta documents
      allow read, write: if false;
    }

    // === ARTICLES COLLECTION (Content Management) ===
    match /articles/{articleId} {
      // Public read access ONLY for published articles
      allow read: if resource.data.status == 'published' && 
                     resource.data.archived != true;
      
      // Admin write access only - secured for production
      allow create, update: if isSignedIn() && isAdmin();
      
      // No deletion - use archived flag instead
      allow delete: if false;
    }

    // Deny everything else by default
    match /{document=**} {
      allow read, write: if false;
    }
  }
}